<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clankerbot Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Babel for in-browser transpilation of React/TypeScript -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://aistudiocdn.com/@google/genai@^1.27.0",
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react/": "https://aistudiocdn.com/react@^19.2.0/",
        "react-dom": "https://aistudiocdn.com/react-dom@^19.2.0",
        "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/"
      }
    }
    </script>
  </head>
  <body class="bg-gray-900">
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI, Type } from '@google/genai';

      // --- CONFIGURATION ---
      // Shim process.env for the browser environment with your provided key
      window.process = { 
        env: { 
          API_KEY: 'AIzaSyC8vaRZ73J_MNdWaLuJPbZ0JZu5lF0HgBs' 
        } 
      };

      // --- TYPES ---
      // Converted from enum to const object to prevent runtime ReferenceErrors in Babel Standalone
      const Status = {
        IDLE: 'idle',
        LOADING: 'loading',
        SUCCESS: 'success',
        ERROR: 'error',
      };

      // --- SERVICES ---

      // Webhook Service
      const sendToGoogleChat = async (webhookUrl: string, text: string): Promise<void> => {
        if (!webhookUrl) {
          throw new Error("Webhook URL is not configured.");
        }

        try {
          const response = await fetch(webhookUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json; charset=UTF-8',
            },
            body: JSON.stringify({ text }),
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ 
              error: { message: 'Failed to parse error response from Google Chat.' } 
            }));
            console.error('Google Chat API Error:', errorData);
            throw new Error(`Failed to send message. Status: ${response.status}. Message: ${errorData.error?.message || 'Unknown error.'}`);
          }
        } catch (error) {
          console.error('Error sending to Google Chat webhook:', error);
          if (error instanceof Error) {
              throw new Error(`Network error or invalid webhook: ${error.message}`);
          }
          throw new Error('An unknown network error occurred while sending the message.');
        }
      };

      // Gemini Service
      const generateReplies = async (chatMessage: string, instructions: string, count: number): Promise<string[]> => {
        const apiKey = window.process.env.API_KEY;
        if (!apiKey) {
          throw new Error("API_KEY is missing.");
        }

        const ai = new GoogleGenAI({ apiKey: apiKey });
        const prompt = `Here is the message to reply to:\n\n"""\n${chatMessage}\n"""`;

        if (count === 1) {
          const systemInstruction = instructions
            ? `You are a helpful assistant in a group chat. Your task is to write a reply. Follow these instructions for the reply: ${instructions}`
            : `You are a helpful assistant in a group chat. Your task is to write a concise and professional reply.`;

          try {
            const response = await ai.models.generateContent({
              model: 'gemini-2.5-flash',
              contents: prompt,
              config: {
                systemInstruction: systemInstruction,
              },
            });
            return [response.text];
          } catch (error) {
            console.error("Gemini API call failed:", error);
            throw new Error("Failed to get response from Gemini. Please check your API key and connection.");
          }
        } else {
          const systemInstruction = `You are a helpful assistant in a group chat. Your task is to write ${count} different and varied replies to a message.
            ${instructions ? `Follow these general instructions for all replies: ${instructions}` : 'The replies should be concise and professional.'}
            Return the replies as a JSON object with a single key "replies" which is an array of strings. Each string in the array is a distinct reply.`;

          try {
            const response = await ai.models.generateContent({
              model: 'gemini-2.5-flash',
              contents: prompt,
              config: {
                systemInstruction: systemInstruction,
                responseMimeType: "application/json",
                responseSchema: {
                  type: Type.OBJECT,
                  properties: {
                    replies: {
                      type: Type.ARRAY,
                      items: {
                        type: Type.STRING,
                        description: 'A single, distinct reply text.'
                      },
                      description: `An array of exactly ${count} different reply strings.`
                    },
                  },
                  required: ['replies'],
                },
              },
            });
            
            const responseText = response.text.trim();
            const result = JSON.parse(responseText);

            if (result && Array.isArray(result.replies)) {
              return result.replies;
            } else {
              throw new Error("Gemini returned an invalid JSON structure.");
            }
          } catch (error) {
            console.error("Gemini API call failed or JSON parsing failed:", error);
            if (error instanceof SyntaxError) {
              throw new Error("Failed to parse Gemini's JSON response.");
            }
            throw new Error("Failed to get response from Gemini.");
          }
        }
      };

      // --- COMPONENTS ---

      // StatusMessage Component
      const LoadingSpinner: React.FC = () => (
        <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-400"></div>
      );

      const SuccessIcon: React.FC = () => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
        </svg>
      );

      const ErrorIcon: React.FC = () => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      );

      const StatusMessage: React.FC<{ status: string; message: string }> = ({ status, message }) => {
        if (status === Status.IDLE) {
          return null;
        }

        let icon;
        let textContent;
        let textColor = 'text-gray-300';

        switch (status) {
          case Status.LOADING:
            icon = <LoadingSpinner />;
            textContent = 'Sending...';
            textColor = 'text-blue-300';
            break;
          case Status.SUCCESS:
            icon = <SuccessIcon />;
            textContent = message;
            textColor = 'text-green-300';
            break;
          case Status.ERROR:
            icon = <ErrorIcon />;
            textContent = message;
            textColor = 'text-red-300';
            break;
          default:
            return null;
        }

        return (
          <div className={`mt-4 p-3 rounded-lg flex items-center space-x-3 bg-gray-800 border border-gray-700 transition-all duration-300`}>
            {icon}
            <p className={`text-sm ${textColor}`}>{textContent}</p>
          </div>
        );
      };

      // BotIcon Component
      const BotIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg 
          xmlns="http://www.w3.org/2000/svg" 
          width="24" 
          height="24" 
          viewBox="0 0 24 24" 
          fill="none" 
          stroke="currentColor" 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round" 
          {...props}
        >
          <path d="M12 8V4H8" />
          <rect x="4" y="12" width="16" height="8" rx="2" />
          <path d="M2 12h2" />
          <path d="M20 12h2" />
          <path d="M12 18v-2" />
          <path d="M12 8a4 4 0 0 1 4 4" />
          <path d="M12 8a4 4 0 0 0-4 4" />
        </svg>
      );

      // App Component
      const App: React.FC = () => {
        const [webhookUrl, setWebhookUrl] = useState('');
        const [message, setMessage] = useState('');
        const [instructions, setInstructions] = useState('');
        const [replyCount, setReplyCount] = useState(1);
        const [status, setStatus] = useState(Status.IDLE);
        const [statusMessage, setStatusMessage] = useState('');

        const handleGenerateAndSend = async (e: React.FormEvent) => {
          e.preventDefault();
          if (!webhookUrl || !message) {
            setStatus(Status.ERROR);
            setStatusMessage('Webhook URL and message cannot be empty.');
            return;
          }

          setStatus(Status.LOADING);
          const replyText = replyCount > 1 ? 'replies' : 'reply';
          setStatusMessage(`Generating ${replyCount} ${replyText} with Gemini...`);

          try {
            const replies = await generateReplies(message, instructions, replyCount);
            
            if (!replies || replies.length === 0) {
                throw new Error("Gemini returned no replies.");
            }

            for (let i = 0; i < replies.length; i++) {
              setStatusMessage(`Sending reply ${i + 1} of ${replies.length} to Google Chat...`);
              await sendToGoogleChat(webhookUrl, replies[i]);
              if (i < replies.length - 1) {
                  await new Promise(resolve => setTimeout(resolve, 500));
              }
            }

            setStatus(Status.SUCCESS);
            setStatusMessage(`Successfully sent ${replies.length} ${replies.length > 1 ? 'replies' : 'reply'}!`);
            setMessage(''); 
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
            setStatus(Status.ERROR);
            setStatusMessage(errorMessage);
          }
        };

        return (
          <div className="min-h-screen bg-gray-900 text-gray-200 flex items-center justify-center p-4 font-sans">
            <div className="w-full max-w-2xl bg-gray-800 border border-gray-700 rounded-lg shadow-2xl p-6 sm:p-8">
              <div className="text-center mb-8">
                  <BotIcon className="w-12 h-12 mx-auto mb-4 text-blue-400" />
                  <h1 className="text-3xl font-bold text-white">Clankerbot Control</h1>
                  <p className="text-gray-400 mt-2">
                      Paste a message from Google Chat, and Gemini will generate and send a reply via your webhook.
                  </p>
              </div>

              <form onSubmit={handleGenerateAndSend} className="space-y-6">
                <div>
                  <label htmlFor="webhookUrl" className="block text-sm font-medium text-gray-300 mb-2">
                    Google Chat Webhook URL
                  </label>
                  <input
                    id="webhookUrl"
                    type="password"
                    value={webhookUrl}
                    onChange={(e) => setWebhookUrl(e.target.value)}
                    placeholder="Enter your webhook URL here"
                    className="w-full bg-gray-700 text-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
                    required
                  />
                </div>

                <div>
                  <label htmlFor="replyCount" className="block text-sm font-medium text-gray-300 mb-2">
                    Number of Replies
                  </label>
                  <input
                    id="replyCount"
                    type="number"
                    value={replyCount}
                    onChange={(e) => {
                      const value = parseInt(e.target.value, 10);
                      setReplyCount(isNaN(value) ? 1 : Math.max(1, Math.min(5, value)));
                    }}
                    min="1"
                    max="5"
                    className="w-full bg-gray-700 text-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
                    required
                  />
                </div>

                <div>
                  <label htmlFor="instructions" className="block text-sm font-medium text-gray-300 mb-2">
                    Reply Instructions <span className="text-gray-500">(Optional)</span>
                  </label>
                  <textarea
                    id="instructions"
                    value={instructions}
                    onChange={(e) => setInstructions(e.target.value)}
                    placeholder="e.g., 'Make it funny and use emojis.' or 'Write a 3 paragraph detailed explanation.'"
                    rows={3}
                    className="w-full bg-gray-700 text-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
                  />
                </div>

                <div>
                  <label htmlFor="message" className="block text-sm font-medium text-gray-300 mb-2">
                    Message to Reply To
                  </label>
                  <textarea
                    id="message"
                    value={message}
                    onChange={(e) => setMessage(e.target.value)}
                    placeholder="Paste the message you want to reply to..."
                    rows={6}
                    className="w-full bg-gray-700 text-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all"
                    required
                  />
                </div>

                <button
                  type="submit"
                  disabled={status === Status.LOADING}
                  className="w-full flex items-center justify-center gap-3 px-6 py-3 bg-blue-600 text-white font-bold rounded-lg shadow-lg transition-all duration-300 transform hover:scale-105 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed disabled:scale-100"
                >
                  Generate & Send {replyCount > 1 ? `${replyCount} Replies` : 'Reply'}
                </button>
              </form>

              <div className="mt-6 min-h-[50px]">
                  <StatusMessage status={status} message={statusMessage} />
              </div>
              
            </div>
          </div>
        );
      };

      // --- MOUNT ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  </body>
</html>