<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Clankerbot Control</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Babel for in-browser transpilation of React/TypeScript -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://aistudiocdn.com/@google/genai@^1.27.0",
        "react": "https://aistudiocdn.com/react@^19.2.0",
        "react/": "https://aistudiocdn.com/react@^19.2.0/",
        "react-dom": "https://aistudiocdn.com/react-dom@^19.2.0",
        "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/"
      }
    }
    </script>
    <style>
      /* Custom scrollbar for textareas */
      textarea::-webkit-scrollbar {
        width: 8px;
      }
      textarea::-webkit-scrollbar-track {
        background: #1f2937; 
      }
      textarea::-webkit-scrollbar-thumb {
        background: #4b5563; 
        border-radius: 4px;
      }
      textarea::-webkit-scrollbar-thumb:hover {
        background: #6b7280; 
      }
    </style>
  </head>
  <body class="bg-gray-900 text-gray-100 font-sans">
    <div id="root"></div>

    <!-- Main Application Script -->
    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState } from 'react';
      import ReactDOM from 'react-dom/client';
      import { GoogleGenAI, Type } from '@google/genai';

      // --- CONFIGURATION ---
      // Shim process.env for the browser environment
      window.process = { 
        env: { 
          API_KEY: 'AIzaSyC8vaRZ73J_MNdWaLuJPbZ0JZu5lF0HgBs' 
        } 
      };

      // --- TYPES ---
      // Fixed: Converted from enum to const object to prevent runtime ReferenceErrors in Babel Standalone
      const Status = {
        IDLE: 'idle',
        LOADING: 'loading',
        SUCCESS: 'success',
        ERROR: 'error',
      };

      // --- SERVICES ---

      // Webhook Service
      const sendToGoogleChat = async (webhookUrl: string, text: string): Promise<void> => {
        if (!webhookUrl) {
          throw new Error("Webhook URL is not configured.");
        }

        try {
          const response = await fetch(webhookUrl, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json; charset=UTF-8',
            },
            body: JSON.stringify({ text }),
          });

          if (!response.ok) {
            const errorData = await response.json().catch(() => ({ 
              error: { message: 'Failed to parse error response from Google Chat.' } 
            }));
            console.error('Google Chat API Error:', errorData);
            throw new Error(`Failed to send message. Status: ${response.status}. Message: ${errorData.error?.message || 'Unknown error.'}`);
          }
        } catch (error) {
          console.error('Error sending to Google Chat webhook:', error);
          if (error instanceof Error) {
              throw new Error(`Network error or invalid webhook: ${error.message}`);
          }
          throw new Error('An unknown network error occurred while sending the message.');
        }
      };

      // Gemini Service
      const generateReplies = async (chatMessage: string, instructions: string, count: number): Promise<string[]> => {
        const apiKey = window.process.env.API_KEY;
        if (!apiKey) {
          throw new Error("API_KEY is missing.");
        }

        const ai = new GoogleGenAI({ apiKey: apiKey });
        const prompt = `Here is the message to reply to:\n\n"""\n${chatMessage}\n"""`;

        if (count === 1) {
          const systemInstruction = instructions
            ? `You are a helpful assistant in a group chat. Your task is to write a reply. Follow these instructions for the reply: ${instructions}`
            : `You are a helpful assistant in a group chat. Your task is to write a concise and professional reply.`;

          try {
            const response = await ai.models.generateContent({
              model: 'gemini-2.5-flash',
              contents: prompt,
              config: {
                systemInstruction: systemInstruction,
              },
            });
            return [response.text];
          } catch (error) {
            console.error("Gemini API call failed:", error);
            throw new Error("Failed to get response from Gemini. Please check your API key and connection.");
          }
        } else {
          const systemInstruction = `You are a helpful assistant in a group chat. Your task is to write ${count} different and varied replies to a message.
            ${instructions ? `Follow these general instructions for all replies: ${instructions}` : 'The replies should be concise and professional.'}
            Return the replies as a JSON object with a single key "replies" which is an array of strings. Each string in the array is a distinct reply.`;

          try {
            const response = await ai.models.generateContent({
              model: 'gemini-2.5-flash',
              contents: prompt,
              config: {
                systemInstruction: systemInstruction,
                responseMimeType: "application/json",
                responseSchema: {
                  type: Type.OBJECT,
                  properties: {
                    replies: {
                      type: Type.ARRAY,
                      items: {
                        type: Type.STRING,
                        description: 'A single, distinct reply text.'
                      },
                      description: `An array of exactly ${count} different reply strings.`
                    },
                  },
                  required: ['replies'],
                },
              },
            });
            
            const responseText = response.text.trim();
            const result = JSON.parse(responseText);

            if (result && Array.isArray(result.replies)) {
              return result.replies;
            } else {
              throw new Error("Gemini returned an invalid JSON structure.");
            }
          } catch (error) {
            console.error("Gemini API call failed or JSON parsing failed:", error);
            if (error instanceof SyntaxError) {
              throw new Error("Failed to parse Gemini's JSON response.");
            }
            throw new Error("Failed to get response from Gemini.");
          }
        }
      };

      // --- COMPONENTS ---

      // StatusMessage Component
      const LoadingSpinner: React.FC = () => (
        <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-400"></div>
      );

      const SuccessIcon: React.FC = () => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-green-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
        </svg>
      );

      const ErrorIcon: React.FC = () => (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      );

      const StatusMessage: React.FC<{ status: string; message: string }> = ({ status, message }) => {
        if (status === Status.IDLE) {
          return null;
        }

        let icon;
        let textContent;
        let textColor = 'text-gray-300';

        switch (status) {
          case Status.LOADING:
            icon = <LoadingSpinner />;
            textContent = 'Processing...';
            textColor = 'text-blue-300';
            break;
          case Status.SUCCESS:
            icon = <SuccessIcon />;
            textContent = message;
            textColor = 'text-green-300';
            break;
          case Status.ERROR:
            icon = <ErrorIcon />;
            textContent = message;
            textColor = 'text-red-300';
            break;
          default:
            return null;
        }

        return (
          <div className={`mt-4 p-3 rounded-lg flex items-center space-x-3 bg-gray-800 border border-gray-700 transition-all duration-300 animate-fade-in`}>
            {icon}
            <p className={`text-sm ${textColor}`}>{textContent}</p>
          </div>
        );
      };

      // Icons
      const BotIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <path d="M12 8V4H8" /><rect x="4" y="12" width="16" height="8" rx="2" /><path d="M2 12h2" /><path d="M20 12h2" /><path d="M12 18v-2" /><path d="M12 8a4 4 0 0 1 4 4" /><path d="M12 8a4 4 0 0 0-4 4" />
        </svg>
      );

      const SendIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}>
          <line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
        </svg>
      );

      // App Component
      const App: React.FC = () => {
        // Shared State
        const [webhookUrl, setWebhookUrl] = useState('');
        const [status, setStatus] = useState(Status.IDLE);
        const [statusMessage, setStatusMessage] = useState('');
        const [activeTab, setActiveTab] = useState('ai'); // 'ai' or 'manual'

        // AI Mode State
        const [inputMessage, setInputMessage] = useState('');
        const [instructions, setInstructions] = useState('');
        const [replyCount, setReplyCount] = useState(1);

        // Manual Mode State
        const [manualMessage, setManualMessage] = useState('');

        const handleAiGenerateAndSend = async (e: React.FormEvent) => {
          e.preventDefault();
          if (!webhookUrl || !inputMessage) {
            setStatus(Status.ERROR);
            setStatusMessage('Webhook URL and message cannot be empty.');
            return;
          }

          setStatus(Status.LOADING);
          const replyText = replyCount > 1 ? 'replies' : 'reply';
          setStatusMessage(`Generating ${replyCount} ${replyText} with Gemini...`);

          try {
            const replies = await generateReplies(inputMessage, instructions, replyCount);
            
            if (!replies || replies.length === 0) {
                throw new Error("Gemini returned no replies.");
            }

            for (let i = 0; i < replies.length; i++) {
              setStatusMessage(`Sending reply ${i + 1} of ${replies.length} to Google Chat...`);
              await sendToGoogleChat(webhookUrl, replies[i]);
              if (i < replies.length - 1) {
                  await new Promise(resolve => setTimeout(resolve, 500));
              }
            }

            setStatus(Status.SUCCESS);
            setStatusMessage(`Successfully sent ${replies.length} ${replies.length > 1 ? 'replies' : 'reply'}!`);
            setInputMessage(''); 
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
            setStatus(Status.ERROR);
            setStatusMessage(errorMessage);
          }
        };

        const handleManualSend = async (e: React.FormEvent) => {
          e.preventDefault();
          if (!webhookUrl || !manualMessage) {
            setStatus(Status.ERROR);
            setStatusMessage('Webhook URL and message cannot be empty.');
            return;
          }

          setStatus(Status.LOADING);
          setStatusMessage('Sending message...');

          try {
            await sendToGoogleChat(webhookUrl, manualMessage);
            setStatus(Status.SUCCESS);
            setStatusMessage('Message sent successfully!');
            setManualMessage('');
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
            setStatus(Status.ERROR);
            setStatusMessage(errorMessage);
          }
        };

        return (
          <div className="min-h-screen bg-gray-900 flex items-center justify-center p-4">
            <div className="w-full max-w-2xl bg-gray-800 border border-gray-700 rounded-xl shadow-2xl p-6 sm:p-8">
              
              {/* Header */}
              <div className="text-center mb-6">
                  <div className="flex justify-center mb-4">
                     <div className="p-3 bg-gray-700 rounded-full">
                        <BotIcon className="w-10 h-10 text-blue-400" />
                     </div>
                  </div>
                  <h1 className="text-3xl font-bold text-white mb-2">Clankerbot Control</h1>
                  <p className="text-gray-400 text-sm">
                      Manage your Google Chat webhook. Auto-reply with AI or send manual messages.
                  </p>
              </div>

              {/* Webhook Input (Always Visible) */}
              <div className="mb-6">
                <label htmlFor="webhookUrl" className="block text-xs uppercase font-semibold text-gray-500 mb-2">
                  Webhook URL
                </label>
                <input
                  id="webhookUrl"
                  type="password"
                  value={webhookUrl}
                  onChange={(e) => setWebhookUrl(e.target.value)}
                  placeholder="https://chat.googleapis.com/..."
                  className="w-full bg-gray-900 border border-gray-700 text-gray-200 rounded-lg p-3 text-sm focus:outline-none focus:border-blue-500 focus:ring-1 focus:ring-blue-500 transition-all placeholder-gray-600"
                />
              </div>

              {/* Tabs */}
              <div className="flex border-b border-gray-700 mb-6">
                <button
                  className={`flex-1 py-3 text-sm font-medium transition-colors duration-200 ${
                    activeTab === 'ai' 
                      ? 'text-blue-400 border-b-2 border-blue-400' 
                      : 'text-gray-500 hover:text-gray-300'
                  }`}
                  onClick={() => { setActiveTab('ai'); setStatus(Status.IDLE); }}
                >
                  AI Auto-Reply
                </button>
                <button
                  className={`flex-1 py-3 text-sm font-medium transition-colors duration-200 ${
                    activeTab === 'manual' 
                      ? 'text-blue-400 border-b-2 border-blue-400' 
                      : 'text-gray-500 hover:text-gray-300'
                  }`}
                  onClick={() => { setActiveTab('manual'); setStatus(Status.IDLE); }}
                >
                  Manual Send
                </button>
              </div>

              {/* AI Auto-Reply Form */}
              {activeTab === 'ai' && (
                <form onSubmit={handleAiGenerateAndSend} className="space-y-5 animate-fade-in">
                  <div className="grid grid-cols-1 sm:grid-cols-3 gap-4">
                     <div className="sm:col-span-2">
                        <label htmlFor="instructions" className="block text-sm font-medium text-gray-300 mb-2">
                          Bot Personality / Instructions
                        </label>
                        <input
                          id="instructions"
                          type="text"
                          value={instructions}
                          onChange={(e) => setInstructions(e.target.value)}
                          placeholder="e.g. Sarcastic, Professional, Pirate..."
                          className="w-full bg-gray-700 border-transparent text-gray-200 rounded-lg p-3 text-sm focus:bg-gray-600 focus:outline-none transition-all"
                        />
                     </div>
                     <div>
                        <label htmlFor="replyCount" className="block text-sm font-medium text-gray-300 mb-2">
                          Count
                        </label>
                        <input
                          id="replyCount"
                          type="number"
                          value={replyCount}
                          onChange={(e) => {
                            const value = parseInt(e.target.value, 10);
                            setReplyCount(isNaN(value) ? 1 : Math.max(1, Math.min(5, value)));
                          }}
                          min="1"
                          max="5"
                          className="w-full bg-gray-700 border-transparent text-gray-200 rounded-lg p-3 text-sm focus:bg-gray-600 focus:outline-none transition-all"
                        />
                     </div>
                  </div>

                  <div>
                    <label htmlFor="inputMessage" className="block text-sm font-medium text-gray-300 mb-2">
                      Original Message
                    </label>
                    <textarea
                      id="inputMessage"
                      value={inputMessage}
                      onChange={(e) => setInputMessage(e.target.value)}
                      placeholder="Paste the message you want the bot to reply to..."
                      rows={5}
                      className="w-full bg-gray-700 border-transparent text-gray-200 rounded-lg p-3 text-sm focus:bg-gray-600 focus:outline-none transition-all"
                    />
                  </div>

                  <button
                    type="submit"
                    disabled={status === Status.LOADING}
                    className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-gradient-to-r from-blue-600 to-blue-500 hover:from-blue-500 hover:to-blue-400 text-white font-bold rounded-lg shadow-lg transition-all duration-300 transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed disabled:scale-100"
                  >
                    <BotIcon className="w-5 h-5" />
                    <span>Generate & Send Reply</span>
                  </button>
                </form>
              )}

              {/* Manual Send Form */}
              {activeTab === 'manual' && (
                <form onSubmit={handleManualSend} className="space-y-5 animate-fade-in">
                  <div>
                    <label htmlFor="manualMessage" className="block text-sm font-medium text-gray-300 mb-2">
                      Your Message
                    </label>
                    <textarea
                      id="manualMessage"
                      value={manualMessage}
                      onChange={(e) => setManualMessage(e.target.value)}
                      placeholder="Type the message you want to send directly to the chat..."
                      rows={8}
                      className="w-full bg-gray-700 border-transparent text-gray-200 rounded-lg p-3 text-sm focus:bg-gray-600 focus:outline-none transition-all"
                    />
                  </div>

                  <button
                    type="submit"
                    disabled={status === Status.LOADING}
                    className="w-full flex items-center justify-center gap-2 px-6 py-3 bg-gradient-to-r from-green-600 to-green-500 hover:from-green-500 hover:to-green-400 text-white font-bold rounded-lg shadow-lg transition-all duration-300 transform active:scale-95 disabled:opacity-50 disabled:cursor-not-allowed disabled:scale-100"
                  >
                    <SendIcon className="w-5 h-5" />
                    <span>Send Message</span>
                  </button>
                </form>
              )}

              {/* Status Message Area */}
              <div className="mt-4 min-h-[60px]">
                <StatusMessage status={status} message={statusMessage} />
              </div>
              
            </div>
          </div>
        );
      };

      // --- MOUNT ---
      const rootElement = document.getElementById('root');
      if (!rootElement) {
        throw new Error("Could not find root element to mount to");
      }
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
    <style>
      @keyframes fade-in {
        from { opacity: 0; transform: translateY(5px); }
        to { opacity: 1; transform: translateY(0); }
      }
      .animate-fade-in {
        animation: fade-in 0.3s ease-out forwards;
      }
    </style>
  </body>
</html>